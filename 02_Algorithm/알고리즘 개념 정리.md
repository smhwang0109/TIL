# 알고리즘 개념 정리

## 인접행렬과 인접리스트

> 둘 다 추상적인 개념일 뿐 어떤 자료형으로 구현해도 상관은 없다.

### 인접행렬

특정 노드들이 서로 연결되어 있는지 아닌지를 알고자 할 때

```python
'''
  1 2 3 4 5
1 X O x x x
2 O X O X X
3 X O X X X
4 X X X X O
5 X X X O X
'''
```

- 장점
  - 노드i와 노드j 가 연결되어 있는지 확인하고 싶을 때, 행렬\[i][j] 만 확인하면 된다. 
    - 시간복잡도 : O(1)
- 단점
  - 전체 노드 개수가 V개 일 때, 노드 i에 연결된 모든 노드를 탐색하려면 전부 탐색해야 한다.
    - 시간복잡도 : O(V)



### 인접리스트

정해지지 않은 어떤 노드들과 연결되어 있는지 알고자 할 때

```python
'''
1: [2]
2: [1, 3]
3: [2]
4: [5]
5: [4]
'''
```

- 장점
  - 전체 노드 개수가 V개, 간선의 개수가 E개 일 때, 노드 i에 연결된 모든 노드를 탐색하기 위해 간선 개수만큼만 탐색하면 된다.
    - 시간 복잡도(O(E))
- 단점 
  - 노드i와 노드j 가 연결되어 있는지 확인하고 싶을 때도 간선의 개수만큼 탐색을 해야 한다.
    - 시간 복잡도(O(E))



## Union Find

> Union Find 는 그래프 알고리즘의 일종으로 상호 배타적 집합(Disjoint-set) 이라고도 하며, 같은 집합에 포함되어 있는지 확인하는 알고리즘입니다.







### 1. 기본 구현

> 기본 구현

```python
def find(num):
    if parent[num] == num:
        return num
    else:
        return find(parent[num])

def union(a, b):
    parent_a = find(a)
    parent_b = find(b)
    if parent_a == parent_b:
        return
    else:
        parent[parent_b] = parent_a
        return
```

- 시간복잡도 : O(N)
- 단점
  - 시간복잡도가 커서 시간초과 오류 발생



### 2. find, union 최적화

> 시간 복잡도를 줄이기 위한 방법

```python
def find(num):
    if parent[num] == num:
        return num
    else:
        parent[num] = find(parent[num])
        return parent[num]

def union(a, b):
    parent_a = find(a)
    parent_b = find(b)
    if parent_a == parent_b:
        return
    elif level[parent_a] > level[parent_b]:
        parent[parent_b] = parent_a
        return
    elif level[parent_a] < level[parent_b]:
        parent[parent_a] = parent_b
        return
    else:
        parent[parent_b] = parent_a
        level[parent_a] += 1
        return 
```

- 시간복잡도 : O(logN)

- 단점

  - parent, level 배열을 두 가지 쓰기 때문에 메모리를 많이 사용

  

### 3. Weighted Union Find

> 메모리 줄이기 위한 방법

```python
def find(num):
    if parent[num] < 0:
        return num

    parent[num] = find(parent[num])
    return parent[num]

def union(a, b):
    parent_a = find(a)
    parent_b = find(b)
    if parent_a == parent_b:
        return


    if parent[parent_a] < parent[parent_b]:
        parent[parent_b] = parent_a
    elif parent[parent_a] > parent[parent_b]:
        parent[parent_a] = parent_b
    else:
        parent[parent_a] -= 1
        parent[parent_b] = parent_a
```

- parent[x] < 0
  - root 노드
- parent[x] >= 0
  - 부모 노드