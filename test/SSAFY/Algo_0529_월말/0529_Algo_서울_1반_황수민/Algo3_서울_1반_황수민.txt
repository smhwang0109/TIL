출발지 정하는 과정 : 
배열 A에서 요소가 2인 위치를 모두 찾아 (i, j) 형태로 리스트에 append하고
부분집합 구하는 함수를 만들어 이 리스트의 요소 2개짜리 부분집합을 구한다.

최소 시간을 찾는 과정 :
앞서 정한 출발지 부분집합 6개를 하나씩 돌며 앞에 요소는 출발지 뒤에 요소는 도착지로
BFS를 이용해 최단 거리를 구한다.
최소 시간은 양측이 모두 움직이다가 둘이 교차하거나 같은 곳에 오는 지점까지의 시간이다.
따라서 최단거리를 구해
최단 거리가 홀수이면 교차한 것이기 때문에 최단 거리를 2로 나눈 몫에 1을 더한 것이 최소시간이고,
최단 거리가 짝수이면 같은 곳에 온 것이기 때문에 2로 나눈 몫이 최소시간이다.

# 깊은 복사를 위한 deepcopy를 부른다.
from copy import deepcopy

# BFS에서 성능 좋은 큐를 만들기 위해 deque를 사용하기 위해 부른다.
from collections import deque

# 출발지 부분 집합 찾는 함수
def define_start(case): 
    if case의 길이 == 2: # 요소가 2개이니까 멈춘다.
        start_case.append(case를 깊은 복사) 
        return
    for i in range(3):
        if start_visited[i]가 0이라면:
            start_visited[i] = 1
            case.append(start_points[i])
            # 재귀
            define_start(case)
            # 원상복귀
            start_visited[i] = 0
            case.pop()

# 최단거리 구하고 2로 나눈 몫으로 결정
def check(start, end):
    # 배열의 길이 N과 현재까지 최단거리 minv를 부른다.
    global N, minv

    # 큐를 만든다.
    q <- deque()

    # 큐에 시작점 위치정보와 현재까지 움직인 거리를 넣는다.
    q.append((start[0], start[1], 0))

    # 큐가 없을 때까지 순회한다.
    while q:
        # 큐에서 가장 왼쪽 것을 가져온다.
        i, j, cnt <- q.popleft()
        
        # 현재까지 최단거리 minv보다 현재까지 움직인 거리가 크거나 같으면 과정을 종료한다.
        if cnt가 minv보다 크거나 같으면:
            return

        # 현재 위치에 방문표시를 한다.
        visited[i][j] <- 1

        # 하, 상, 우, 좌를 움직인다.
        for k in range(4):
            # 움직일 위치를 변수화한다.
            n_i <- i + di[k]
            n_j <- j + dj[k]
            
            # 도착지에 도착했다면 이미 앞에서 검증했기 때문에 minv에 cnt + 1을 넣고 과정을 끝낸다.
            if end[0]가 n_i과 같고 end[1]이 n_j과 같다면:
                minv <- cnt + 1
                return
            
            # 도착지가 아니라면
            # 배열의 범위를 벗어나지 않았는지 확인한다.
            if n_i과 n_j가 모두 0보다 크거나 같고 N보다 작으면:

                # 새 위치가 아직 방문하지 않았고, 갈 수 있는 방이라면
                if visited[n_i][n_j]와 A[n_i][n_j]가 모두 0이면:
                    # 큐에 새 위치와 새 위치까지 움직인 거리를 넣는다.
                    q.append((n_i, n_j, cnt + 1))

# 하, 상, 우, 좌를 움직이기 위한 리스트 
di <- [1, -1, 0, 0]
dj <- [0, 0, 1, -1]

N <- int(input())
A <- [list(map(int, input().split())) for _ in range(N)]

# 시작점으로 사용가능한 위치(2가 있는 모든 위치)를 저장할 리스트
start_points <- []

# 시작점 부분집합 구할 때 방문 여부 저장할 리스트
start_visited <- [0] * 3

# 시작점 부분집합 저장할 리스트
start_case <- []

# 2가 있는 모든 위치를 알아내 start_points에 저장한다.
for i in range(N):
    for j in range(N):
        if A[i][j]가 2와 같으면:
            start_points.append((i,j))

# 시작점 부분집합을 모두 찾아 start_case에 저장한다.
define_start([])

# 값이 큰 최소값을 만들어 놓는다.
minv <- float('inf')

# 시작점 부분집합을 하나씩 돌면서 최단 거리를 구한 후 minv에 저장한다.
for case in start_case:
    # 매번 돌 때 마다 방문 기록을 초기화한다.
    visited <- [[0]*N for _ in range(N)]
    check(case[0], case[1])

# 최단거리가
# 홀수일 때는 2로 나눈 몫의 + 1
# 짝수일 때는 2로 나눈 몫을
# 구하는 쉬운 방법
print((minv+1) // 2)
